/* PX-REM Mixin */

// $in-mq is used to detect if mixin is being called inside a
//   media query. If so, no px fallback is needed.
// Mixin takes two parameters:
// - $property: CSS property name
// - $values: list of pixel values for shorthand (like margin / padding)
// Foreach $value, mixin strips unit, converts to rem and
//   adds both px & rem values to appropriate lists
// Only outputs $pxValues if (1) not in MQ and (2) lists actually differ
// Outputs $remValues
$in-mq: false !global;

@mixin px-rem($property, $values...) {
	$pxValues: ();
	$remValues: ();

	@each $value in $values {
		$val: strip-units($value);
		@if index("initial" "inherit" "auto" 0, $value) != null {
			$pxValues: append($pxValues, $val);
			$remValues: append($remValues, $val);
		} @else {
			$pxValues: append($pxValues, $val*1px);
			$remValues: append($remValues, rem($val) );
		}
	}
	@if $in-mq = false and $pxValues != $remValues {
		#{$property}: $pxValues;
	}
	#{$property}: $remValues;
}

// Shorthand mixin to make using px-rem for font-size easier
@mixin fs($number) {
	@include px-rem(font-size, $number);
}

/* CENTER Mixin */

// Use CSS transforms to center elements horizontally & vertically
// I never use it so w/e
@mixin center($hz:true,$vt:true) {
	.csstransforms & {
		position: relative;
		@if $hz == true and $vt == true {
			top: 50%;
			left: 50%;
			transform: translateX(-50%) translateY(-50%);
		} @else if $hz == true {
			left: 50%;
			transform: translateX(-50%);
		} @else if $vt == true {
			top: 50%;
			transform: translateY(-50%);
		}
	}
}

/* HIDE Mixin */

// Bullet proof way to hide elements from breakpoint
// - $bp: key from $breakpoints map
// - $reset: reverses previous of mixin
@mixin hide($bp, $reset: null) {
	@if $reset {
		@include bp($bp) {
			display: block;
			width: auto;
			height: auto;
			overflow: auto;
			clip: none;
		}
	} @else {
		@if $bp == all {
			display: none;
			width: 0;
			height: 0;
			overflow: hidden;
			clip: rect(0,0,0,0);
		} @else {
			@include bp($bp) {
				display: none;
				width: 0;
				height: 0;
				overflow: hidden;
				clip: rect(0,0,0,0);
			}
		}
	}
}

/* BP Mixin (breakpoints) */

// Generate min-width media queries from $breakpoints map data
// - $name: key from $breakpoints
// Switches $in-mq on & off for px-rem() mixin
// Output content wrapped in MQ
@mixin bp($name) {
	@if map-has-key($breakpoints, $name) == null {
		@warn "Invalid breakpoint `#{$name}`.";
	} @else {
		@if map-get($breakpoints, $name) {
			$in-mq: true !global;
			@media (min-width: map-get($breakpoints, $name)) {
				@content;
			}
			$in-mq: false !global;
		} @else {
			@content;
		}
	}
}

/* FSMOOTH Mixin */

// If $yes != no, outputs Chrome & Firefox (Mac) antialiasing
// If $yes = no, resets to default subpixel-antialiasing
@mixin fsmooth($yes: yes) {
	@if $yes == 'no' {
		-webkit-font-smoothing: subpixel-antialiased;
		-moz-osx-font-smoothing: subpixel-antialiased;
	} @else {
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: antialiased;
	}
}

// $config is a susy config map, I've added 'breakpoint' key:
//   breakpoint takes a list that fits into breakpoint() mixin.
// $cols takes a value that matches Susy's span, location, layout pattern,
//   or $cols takes the word 'container' to call @include container in
//   in current mq context
// $grid is option: if true, calls show-grid() in current mq context

@mixin simple-susy-breakpoint(
	$config,
	$columns,
	$grid: false
) {
	@if map-get($config, breakpoint) == null {
		@warn 'The map you specified does not have a breakpoint value.';
	} @else {
		$breakpoint: map-get($config, breakpoint);
		@include susy-breakpoint($breakpoint, $config) {
			@if $columns == container {
				@include container;
				@if $grid == true {
					@include show-grid;
				}
			} @else {
				@include span($columns);
			}
		}
	}
}


@function get_bp($label) {
	@return map-get($breakpoints, $label);
}

@function round-num($num) {
	@return round($num*100)/100;
}

@mixin spread-value($property, $value-start, $value-end, $bp-start: small, $bp-end: large) {
	@if type-of($value-start) != number or type-of($value-end) != number {
		@warn 'Either $value-start or $value-end is not a number: `#{$value-start}` | `#{$value-end}';
	} @else {
		@if $property == font-size {
			@include fs($value-start);
		} @else {
			#{$property}: #{$value-start};
		}
		$value-distance: $value-end - $value-start;
		$bp-distance: get_bp($bp-end) - get_bp($bp-start);
		$bp-keys: map-keys($breakpoints);
		$bp-list: ();
		$i: index($bp-keys, $bp-start);
		@while $i <= length($bp-keys) and nth($bp-keys, $i) != $bp-end {
			$i: $i + 1;
			$bp-list: join($bp-list, nth($bp-keys, $i));
		}
		@each $key in $bp-list {
			$percentage: ( get-bp($key) - get_bp($bp-start) ) / $bp-distance;
			$output: round-num( ( $value-distance * $percentage ) + $value-start );
			@include breakpoint($key) {
				@if $property == font-size {
					@include fs($output);
				} @else {
					#{$property}: #{$output};
				}
			}
		}
	}
}

@mixin no-spread-value($property, $values...) {
	@if $property == font-size {
		@include fs(nth($values, 1));
	} @else {
		#{$property}: nth($values, 1);
	}
	@if length($values) == length(map-keys($breakpoints)) {
		@each $key in $bp-keys {
			@include breakpoint($key) {
				@if $property == font-size {
					@include fs(nth($values, index($bp-keys, $key)));
				} @else {
					#{$property}: nth($values, index($bp-keys, $key));
				}
			}
		}
	} @else {
		@warn 'You need as many values as there are breakpoints for this mixin.';
	}
}

@function color-variation($color, $variation: false) {
	@if map-has-key($colors, $color) != null {
		$color: map-get($colors, $color);
	} @else {
		@if type-of($color) != color {
			@warn "Invalid color name: #{$color}.";
		}
	}
	@if $variation {
		@if map-has-key($variations, $variation) == null {
			@warn "Invalid $variation: `#{$variation}`.";
		} @else {
			$this-variation: map-get($variations, $variation);
			$args: join(map-get($this-variation, function), $color);
			@if map-get($this-variation, parameters) != null {
				$args: join($args, map-get($this-variation, parameters));
			}
			@return call($args...);
		}
	}
	@return $color;
}